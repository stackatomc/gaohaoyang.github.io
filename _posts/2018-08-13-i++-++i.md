---
layout: post
title:  "i++与++i的区别"
categories: Java
tags: Java
author: MayerFang
---

* content
{:toc}

>i++与++i的区别





**Outline**
- [i++与++i的区别](#i++与++i的区别)
	- [第一点 左值与右值的区别](#第一点 左值与右值的区别)
	- [第二点 是否有新空间开辟](#第二点 是否有新空间开辟)
	- [第三点 所产生的汇编代码不同、指令数不同等](#第三点 所产生的汇编代码不同、指令数不同等)



---

# i++与++i的区别

标签：Java

---

## 第一点 左值与右值的区别

- ++i返回左值，i++返回右值
- [为什么(i++)不能做左值，而(++i)可以](https://blog.csdn.net/zlhy_/article/details/8349300)(参考来源)

```java
// 前缀形式：
int& int::operator++() //这里返回的是一个引用形式，就是说函数返回值也可以作为一个左值使用
{//函数本身无参，意味着是在自身空间内增加1的
  *this += 1;  // 增加
  return *this;  // 取回值
}

//后缀形式:
const int int::operator++(int) //函数返回值是一个非左值型的，与前缀形式的差别所在。
{//函数带参，说明有另外的空间开辟
  int oldValue = *this;  // 取回值
  ++(*this);  // 增加
  return oldValue;  // 返回被取回的值
}
```
---

## 第二点 是否有新空间开辟
	- ++i在原值上操作，i++有新空间开辟
	- [《有关编程、重构及其他的终极问题？》——29.在迭代器上请使用前置自增操作符（++i），不要使用后置自增操作符（i++）](https://blog.csdn.net/headman/article/details/75144116)(参考来源)
	- 总结：
		- 关于性能方面，一般情况由于编译器可优化，所以i++与++i差异不大
		- 而当Debug模式下可能出现性能问题（书中原句:`比如，在这篇文章中就有一些例子来评估在debug模式下使用前置和后置自增操作符的运行时间，我们可以看到使用后置自增操作符基本要多4倍的运行时间。`）
		- 只从性能上考虑，建议使用++i，从可读性角度上选择i++更适合阅读
	- 另外，C++中iterator的自增使用++it 性能明显由于it++；Java中好像不直接涉及该点

---

## 第三点 所产生的汇编代码不同、指令数不同等

>知乎用户  LambdaCalc
>i++和++i的另一个区别是，它们所产生的汇编代码不同。
在IA32架构下，gcc编译器在不使用优化时，编译i++会产生三条指令。
而编译++i则只有一条指令。
因此，++i是一个原子操作，而i++不是。[在程序开发中，++i与i++有什么区别？](https://www.zhihu.com/question/19811087)（参考来源）